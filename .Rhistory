# creating the qqplot function.
QQ.pooled = function(data, y) {
n.pts = min( length(data$rating), length(y))
probs = seq(from = 0, to = 1, length.out = n.pts)
q1 = quantile(data$rating, probs= probs)
q2 = quantile(y, probs=probs )
return( data.frame(q1 = q1, q2 = q2, quantile = probs) )
}
# the plotting of qqplot.
QQ.plot = ddply(ratings, "variable", QQ.pooled, y=ratings.only$rating)
ggplot(data = QQ.plot, mapping=aes(y = q1, x=q2)) + facet_wrap('variable') + geom_point(size=.5) + geom_abline() + labs(title = "Q-Q plot of rating of distribution of rating of all movie genres", x='Ratings, All Movies', y='Ratings, Genre')
# fill in
# ----------Received Help from Zinedine and Andre----------
#creating a subset 1900 - 2000
time.period.sub = subset(movies, subset = year >= 1900 & year <= 2000)
# adding a time period to identify each years.
time.period.sub$time.period = with(time.period.sub, cut(x = year, breaks = c(1900, 1921, 1941, 1961, 1981, 2001), labels = c("1900 - 1920", "1921 - 1940", "1941 - 1960" , "1961 - 1980", "1981 - 2000"), right = FALSE))
# meltiing the genres into a sing column
time.period.melt = melt(time.period.sub, id.vars = c("time.period", "rating"), measure.vars = c("Action", "Animation", "Comedy", "Drama", "Documentary", "Romance", "Short"))
time.period.melt = subset(time.period.melt, subset = value == 1)
#creating a data frame for the raiting only.
time.period.melt.rating = time.period.melt["rating"]
#the qplot
ggplot(data = time.period.melt, mapping = aes(sample = rating)) + stat_qq() + facet_grid(variable ~ time.period) + stat_qq(data = time.period.melt.rating, mapping = aes(sample = rating), geom = "line") + labs(y = "genres. rating", x = "years" )
# fill in
# ----------Received Help from Zinedine and Andre----------
#creating a subset 1900 - 2000
time.period.sub = subset(movies, year >= 1900 & year <= 2000)
# adding a time period to identify each years.
time.period.sub$time.period = with(time.period.sub, cut(x = year, breaks = c(1900, 1921, 1941, 1961, 1981, 2001), labels = c("1900 - 1920", "1921 - 1940", "1941 - 1960" , "1961 - 1980", "1981 - 2000"), right = FALSE))
time.period.sub
# meltiing the genres into a sing column
time.period.melt = melt(time.period.sub, id.vars = c("time.period", "rating"), measure.vars = c("Action", "Animation", "Comedy", "Drama", "Documentary", "Romance", "Short"))
time.period.melt = subset(time.period.melt, subset = value == 1)
#creating a data frame for the raiting only.
time.period.melt.rating = time.period.melt["rating"]
#the qplot
ggplot(data = time.period.melt, mapping = aes(sample = rating)) + stat_qq() + facet_grid(variable ~ time.period) + stat_qq(data = time.period.melt.rating, mapping = aes(sample = rating), geom = "line") + labs(y = "genres. rating", x = "years" )
# fill in
# ----------Received Help from Zinedine and Andre----------
# Creating a subset 1900 - 2000
time.period.sub = subset(movies, year >= 1900 & year <= 2000)
# Creating time.period column with cut year segments
time.period.sub$time.period = with(time.period.sub, cut(x = year, breaks = c(1900, 1921, 1941, 1961, 1981, 2001), labels = c("1900 - 1920", "1921 - 1940", "1941 - 1960" , "1961 - 1980", "1981 - 2000"), right = FALSE))
# Meltiing the genres into a sing column
time.period.melt = melt(time.period.sub, id.vars = c("time.period", "rating"), measure.vars = c("Action", "Animation", "Comedy", "Drama", "Documentary", "Romance", "Short"))
# Creating a subset for ratings with value = 1.
time.period.melt = subset(time.period.melt, value == 1)
# Creating a data frame for the raiting only.
time.period.melt.rating = time.period.melt["rating"]
# ----------qplot output----------
ggplot(data = time.period.melt, mapping = aes(sample = rating)) + stat_qq() + facet_grid(variable ~ time.period) + stat_qq(data = time.period.melt.rating, mapping = aes(sample = rating), geom = "line") + labs(y = "Rating by Genre", x = "Years" )
# ----------QQ plot output----------
qq.values.time.period = ddply(time.period.melt, c("variable", "time.period"), QQ.pooled, y = time.period.melt.rating$rating)
ggplot(data = qq.values.time.period, mapping = aes(x=q1, y=q2)) + geom_point() + geom_abline() + facet_grid(variable ~ time.period) + labs(y = "Rating by Genre", x = "Years" )
# fill in
# Scatterplot function that takes in a per capita column value, a function (in this case population) and a plot title
per.capita.scatterplot = function(x, n, main.title) {
CI.data = with(county.data, binom.confint(x = x, n = n, methods = 'exact'))
county.augment = with(CI.data,
mutate(county.data,
lower.CI = lower, upper.CI = upper, per.capita = mean))
kable( arrange(county.augment, desc(x))[, c("name", "population", "violent.crimes", "per.capita", "lower.CI")], digits=4)
ggplot(county.augment, aes(x=n, y=per.capita)) + geom_point() + geom_smooth() + scale_x_log10() + labs(x = "Population", y = "Per Capita", title = main.title)
}
# Violent Crimes by Population
per.capita.scatterplot(county.data$violent.crimes, county.data$population, "Violent Crimes by Population")
library(ggplot2)
library(plyr)
library(reshape2)
library(knitr)
library(binom)
county.data = read.csv(file = 'county_data.csv', header=TRUE)
load('county_ggplot.rda')
# fill in
# Scatterplot function that takes in a per capita column value, a function (in this case population) and a plot title
per.capita.scatterplot = function(x, n, main.title) {
CI.data = with(county.data, binom.confint(x = x, n = n, methods = 'exact'))
county.augment = with(CI.data,
mutate(county.data,
lower.CI = lower, upper.CI = upper, per.capita = mean))
kable( arrange(county.augment, desc(x))[, c("name", "population", "violent.crimes", "per.capita", "lower.CI")], digits=4)
ggplot(county.augment, aes(x=n, y=per.capita)) + geom_point() + geom_smooth() + scale_x_log10() + labs(x = "Population", y = "Per Capita", title = main.title)
}
# Violent Crimes by Population
per.capita.scatterplot(county.data$violent.crimes, county.data$population, "Violent Crimes by Population")
# Births by Population
per.capita.scatterplot(county.data$births, county.data$population, "Births by Population")
# Deaths by Population
per.capita.scatterplot(county.data$deaths, county.data$population, "Deaths by Population")
# Infant Deaths by Population
per.capita.scatterplot(county.data$infant.deaths, county.data$population, "Infant Deaths by Population")
# fill in
find.std.residual = function(data, variable, null.prob) {
data = mutate(data, expected.null = variable * null.prob,
std.dev.null = sqrt(expected.null * (1 - null.prob)),
residual = variable - expected.null,
std.residual = residual / std.dev.null)
# Decreasing data order by std.residual
return(data.frame(arrange(data, desc(std.residual))))
}
# fill in
# Initial function call
# Retrieving only the top 15 records by violent crime rates
top.15.crimes = find.std.residual(county.data, county.data$violent.crimes, 0.01)[1:15, ]
top.15.crimes
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# Getting the Violent Crime per Capita Rate
crime.rate.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Passing the crime rate as the null hypothesis
map.std.residual(county.gg, find.std.residual(county.data, county.data$violent.crimes, crime.rate.per.capita)[1:15,])
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
county_list
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
county.merge
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
return (county.merge)
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# Getting the Violent Crime per Capita Rate
crime.rate.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Passing the crime rate as the null hypothesis
map.std.residual(county.gg, find.std.residual(county.data, county.data$violent.crimes, crime.rate.per.capita)[1:15,])
# fill in
# Getting the Violent Crime per Capita Rate
crime.rate.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Passing the crime rate as the null hypothesis
map.std.residual(county.gg, find.std.residual(county.data, county.data$violent.crimes, crime.rate.per.capita)[1:15,])
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
return (county.merge)
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
county.merge
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
county.merge
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# ----------Code taken from Exercise 6 solution + Help from Zinedine----------
# Creation of the map.std.residual function with 2 parameters which are county.gg, county.data
map.std.residual = function(county.gg, county.data) {
# Getting the US.per.capita by dividing the sum of violent.crimes to population
US.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Merging the 2 data frames by the columns fips and STCOU
county.merge = merge(x = county.gg, y = county.data, by.x = "fips", by.y = "STCOU")
# Arranging the data frame county.merge according to order
county.merge = arrange(county.merge, order)
# Starting of data map_data
county_list = map_data("county")
# ggplot automatically returns value of the map.std.residual function that creates the map
ggplot() + geom_map(data = county_list, map = county_list, mapping = aes(x = long, y = lat, map_id = region), col = "white", fill = "grey") + geom_polygon(data = county.merge, mapping = aes(x = long, y = lat, group = group, fill = std.residual)) + coord_map() + labs(x = "Longitude", y = "Latitude", fill = "Standard Residual", group = "Counties", title = "Top 15 Counties \n with High Standard Residual") + scale_fill_gradientn(limits = c(0,4000), colours=c("grey", "violet", "blue"), breaks=c(0, 1000 , 2000, 3000, 4000))
}
# Running the function with the appropriate data sets and adding some styles to the created map
map.std.residual(county.gg, top.15.crimes)
# fill in
# Getting the Violent Crime per Capita Rate
crime.rate.per.capita = sum(county.data$violent.crimes) / sum(county.data$population)
# Passing the crime rate as the null hypothesis
map.std.residual(county.gg, find.std.residual(county.data, county.data$violent.crimes, crime.rate.per.capita)[1:15,])
library(plyr)
library(ggplot2)
library(reshape2)
expenditures = read.csv(file = 'dataset_hw4.csv', header = TRUE)
# fill in
# Subset for home categories
apartments.and.homes = subset(expenditures, home.type == "apartment or flat" | home.type == "high-rise" | home.type == "single family detached")
# if else statement classified single family detached homes into "homes" category
# Other types of homes (apartments, high-rises and flats) get put into "apartments" category
apartments.and.homes$categories = ifelse(apartments.and.homes$home.type == "single family detached", "homes", "apartments")
# Method 1: Plotting housing expenditures data by categories mentioned above, and colored by home type
qplot(sample = housing, data = apartments.and.homes, color=home.type) + facet_wrap(~ categories) +
labs(x = "Quantiles", y = "Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class")
# Method 2: Plotting with ggplot and stat_qq
ggplot(apartments.and.homes, mapping = aes(sample = housing)) +
stat_qq(geom = "line", distribution = "qunif", size = 0.5) +
facet_wrap(~ categories) +
labs(x = "Quantiles", y = "Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class")
# fill in
# log transform for housing expenditures column being stored in "log.housing"
apartments.and.homes$log.housing = log(apartments.and.homes$housing)
# subset to remove zero or negative housing expenditure values
apartments.and.homes = subset(apartments.and.homes, subset = !is.na(housing) & housing > 0)
# Method 1: plotting with log housing expenditures data, grouping by category and coloring by home type
qplot(sample = log.housing, data = housing.expenditures.subset, color=home.type) + facet_wrap(~ categories) +
labs(x="Quantiles", y="Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class", subtitle = "(With Log Transform)")
# Method 2: Plotting with ggplot and stat_qq
ggplot(apartments.and.homes, mapping = aes(sample = log.housing)) + stat_qq(geom="line", distribution="qunif", size = 0.5) + facet_wrap(~ categories) + labs(x="Quantiles", y="Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class", subtitle = "(With Log Transform)")
# fill in
library(ggplot2movies)
# if else statement to create two year categories splitting before and after 1930
movies$year.groupings = ifelse(movies$year >= 1930, "1930 and Beyond", "Before 1930")
# log transform for movie rating column
movies$log.rating = log(movies$rating)
# plotting log rating data according to year and grouping by year categories
# geom_line is added to color years according to 1930 split
# stat_summary adds average ratings point in black for each year
ggplot(movies, aes(x = year, y = log.rating)) +
geom_point(aes(color = factor(year >= 1930)), size = 0.5) +
stat_summary(fun.data = mean_cl_boot, geom = "point", color = "black", size = 1) +
facet_wrap(~ year.groupings, nrow = 2) +
labs(title = "Film Ratings by Year Sliced Before and After 1930")
# fill in
# ----------Received Help from Zinedine and Andre----------
# ----------qplot output----------
# creating the subset for movies genres along with the year and rating.
ratings = subset(movies, select = c('year', 'rating', names(movies)[18:24]))
# Melting all genres in a single column
ratings = melt(ratings, measure.vars = names(movies)[18:24])
# Creating a subset for ratings with value = 1.
ratings = subset(ratings, value == 1)
# setting a data frame for rating column only.
ratings.only = ratings["rating"]
# plotting my subset using qplot.
ggplot(data = ratings, mapping=aes(sample=rating)) + stat_qq(dist='qunif') + facet_wrap(~ variable) + stat_qq(data=ratings.only, mapping=aes(sample=rating), dist='qunif', geom='line') + labs(title = "qplot of ratings per genre", x='Ratings, All Movies', y='Ratings, Genre')
# ----------QQ plot output----------
# creating the qqplot function.
QQ.pooled = function(data, y) {
n.pts = min( length(data$rating), length(y))
probs = seq(from = 0, to = 1, length.out = n.pts)
q1 = quantile(data$rating, probs= probs)
q2 = quantile(y, probs=probs )
return( data.frame(q1 = q1, q2 = q2, quantile = probs) )
}
# the plotting of qqplot.
QQ.plot = ddply(ratings, "variable", QQ.pooled, y=ratings.only$rating)
ggplot(data = QQ.plot, mapping=aes(y = q1, x=q2)) + facet_wrap('variable') + geom_point(size=.5) + geom_abline() + labs(title = "QQ plot of ratings per genre", x='Ratings, All Movies', y='Ratings, Genre')
# fill in
# ----------Received Help from Zinedine and Andre----------
# Creating a subset 1900 - 2000
time.period.sub = subset(movies, year >= 1900 & year <= 2000)
# Creating time.period column with cut year segments
time.period.sub$time.period = with(time.period.sub, cut(x = year, breaks = c(1900, 1921, 1941, 1961, 1981, 2001), labels = c("1900 - 1920", "1921 - 1940", "1941 - 1960" , "1961 - 1980", "1981 - 2000"), right = FALSE))
# Meltiing the genres into a sing column
time.period.melt = melt(time.period.sub, id.vars = c("time.period", "rating"), measure.vars = c("Action", "Animation", "Comedy", "Drama", "Documentary", "Romance", "Short"))
# Creating a subset for ratings with value = 1.
time.period.melt = subset(time.period.melt, value == 1)
# Creating a data frame for the raiting only.
time.period.melt.rating = time.period.melt["rating"]
# ----------qplot output----------
ggplot(data = time.period.melt, mapping = aes(sample = rating)) + stat_qq() + facet_grid(variable ~ time.period) + stat_qq(data = time.period.melt.rating, mapping = aes(sample = rating), geom = "line") + labs(y = "Rating by Genre", x = "Years" )
# ----------QQ plot output----------
qq.values.time.period = ddply(time.period.melt, c("variable", "time.period"), QQ.pooled, y = time.period.melt.rating$rating)
ggplot(data = qq.values.time.period, mapping = aes(x=q1, y=q2)) + geom_point() + geom_abline() + facet_grid(variable ~ time.period) + labs(y = "Rating by Genre", x = "Years" )
library(plyr)
library(ggplot2)
library(reshape2)
expenditures = read.csv(file = 'dataset_hw4.csv', header = TRUE)
# fill in
# Subset for home categories
apartments.and.homes = subset(expenditures, home.type == "apartment or flat" | home.type == "high-rise" | home.type == "single family detached")
# if else statement classified single family detached homes into "homes" category
# Other types of homes (apartments, high-rises and flats) get put into "apartments" category
apartments.and.homes$categories = ifelse(apartments.and.homes$home.type == "single family detached", "homes", "apartments")
# Method 1: Plotting housing expenditures data by categories mentioned above, and colored by home type
qplot(sample = housing, data = apartments.and.homes, color=home.type) + facet_wrap(~ categories) +
labs(x = "Quantiles", y = "Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class")
# Method 2: Plotting with ggplot and stat_qq
ggplot(apartments.and.homes, mapping = aes(sample = housing)) +
stat_qq(geom = "line", distribution = "qunif", size = 0.5) +
facet_wrap(~ categories) +
labs(x = "Quantiles", y = "Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class")
# fill in
# log transform for housing expenditures column being stored in "log.housing"
apartments.and.homes$log.housing = log(apartments.and.homes$housing)
# subset to remove zero or negative housing expenditure values
apartments.and.homes = subset(apartments.and.homes, subset = !is.na(housing) & housing > 0)
# Method 1: plotting with log housing expenditures data, grouping by category and coloring by home type
qplot(sample = log.housing, data = housing.expenditures.subset, color=home.type) + facet_wrap(~ categories) +
labs(x="Quantiles", y="Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class", subtitle = "(With Log Transform)")
# fill in
# log transform for housing expenditures column being stored in "log.housing"
apartments.and.homes$log.housing = log(apartments.and.homes$housing)
# subset to remove zero or negative housing expenditure values
apartments.and.homes = subset(apartments.and.homes, subset = !is.na(housing) & housing > 0)
# Method 1: plotting with log housing expenditures data, grouping by category and coloring by home type
qplot(sample = log.housing, data = apartments.and.homes, color=home.type) + facet_wrap(~ categories) +
labs(x="Quantiles", y="Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class", subtitle = "(With Log Transform)")
# Method 2: Plotting with ggplot and stat_qq
ggplot(apartments.and.homes, mapping = aes(sample = log.housing)) + stat_qq(geom="line", distribution="qunif", size = 0.5) + facet_wrap(~ categories) + labs(x="Quantiles", y="Housing Expenditures", title = "Quantile Plot of Household Expenditures by Class", subtitle = "(With Log Transform)")
# fill in
library(ggplot2movies)
# if else statement to create two year categories splitting before and after 1930
movies$year.groupings = ifelse(movies$year >= 1930, "1930 and Beyond", "Before 1930")
# log transform for movie rating column
movies$log.rating = log(movies$rating)
# plotting log rating data according to year and grouping by year categories
# geom_line is added to color years according to 1930 split
# stat_summary adds average ratings point in black for each year
ggplot(movies, aes(x = year, y = log.rating)) +
geom_point(aes(color = factor(year >= 1930)), size = 0.5) +
stat_summary(fun.data = mean_cl_boot, geom = "point", color = "black", size = 1) +
facet_wrap(~ year.groupings, nrow = 2) +
labs(title = "Film Ratings by Year Sliced Before and After 1930")
# fill in
# ----------Received Help from Zinedine and Andre----------
# ----------qplot output----------
# creating the subset for movies genres along with the year and rating.
ratings = subset(movies, select = c('year', 'rating', names(movies)[18:24]))
# Melting all genres in a single column
ratings = melt(ratings, measure.vars = names(movies)[18:24])
# Creating a subset for ratings with value = 1.
ratings = subset(ratings, value == 1)
# setting a data frame for rating column only.
ratings.only = ratings["rating"]
# plotting my subset using qplot.
ggplot(data = ratings, mapping=aes(sample=rating)) + stat_qq(dist='qunif') + facet_wrap(~ variable) + stat_qq(data=ratings.only, mapping=aes(sample=rating), dist='qunif', geom='line') + labs(title = "qplot of ratings per genre", x='Ratings, All Movies', y='Ratings, Genre')
# ----------QQ plot output----------
# creating the qqplot function.
QQ.pooled = function(data, y) {
n.pts = min( length(data$rating), length(y))
probs = seq(from = 0, to = 1, length.out = n.pts)
q1 = quantile(data$rating, probs= probs)
q2 = quantile(y, probs=probs )
return( data.frame(q1 = q1, q2 = q2, quantile = probs) )
}
# the plotting of qqplot.
QQ.plot = ddply(ratings, "variable", QQ.pooled, y=ratings.only$rating)
ggplot(data = QQ.plot, mapping=aes(y = q1, x=q2)) + facet_wrap('variable') + geom_point(size=.5) + geom_abline() + labs(title = "QQ plot of ratings per genre", x='Ratings, All Movies', y='Ratings, Genre')
# fill in
# ----------Received Help from Zinedine and Andre----------
# Creating a subset 1900 - 2000
time.period.sub = subset(movies, year >= 1900 & year <= 2000)
# Creating time.period column with cut year segments
time.period.sub$time.period = with(time.period.sub, cut(x = year, breaks = c(1900, 1921, 1941, 1961, 1981, 2001), labels = c("1900 - 1920", "1921 - 1940", "1941 - 1960" , "1961 - 1980", "1981 - 2000"), right = FALSE))
# Meltiing the genres into a sing column
time.period.melt = melt(time.period.sub, id.vars = c("time.period", "rating"), measure.vars = c("Action", "Animation", "Comedy", "Drama", "Documentary", "Romance", "Short"))
# Creating a subset for ratings with value = 1.
time.period.melt = subset(time.period.melt, value == 1)
# Creating a data frame for the raiting only.
time.period.melt.rating = time.period.melt["rating"]
# ----------qplot output----------
ggplot(data = time.period.melt, mapping = aes(sample = rating)) + stat_qq() + facet_grid(variable ~ time.period) + stat_qq(data = time.period.melt.rating, mapping = aes(sample = rating), geom = "line") + labs(y = "Rating by Genre", x = "Years" )
# ----------QQ plot output----------
qq.values.time.period = ddply(time.period.melt, c("variable", "time.period"), QQ.pooled, y = time.period.melt.rating$rating)
ggplot(data = qq.values.time.period, mapping = aes(x=q1, y=q2)) + geom_point() + geom_abline() + facet_grid(variable ~ time.period) + labs(y = "Rating by Genre", x = "Years" )
